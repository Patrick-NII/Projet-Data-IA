
# Streamlit est un Framework Python, il permet de cr√©er des applications 
# web (principalement pour le Machine learning et la data science) de mani√®re simple et rapide.

# Requests permet d'envoyer des requ√™tes HTTP dans Python.
import streamlit as st
import requests



# D√©finit une fonction nomm√©e "fetch_popular_movies" qui prend trois arguments : api_key, language 
# et page, avec les deux derniers ayant des valeurs par d√©faut. Cette fonction est utilis√©e pour
# r√©cup√©rer les films populaires √† partir de l'API de TMDB.

# "URL" cr√©e l'URL pour l'API TMDB en utilisant la cl√© API (disponible via la section API sur TMDB)
# la langue sp√©cifi√©e (language) et le num√©ro de page sp√©cifi√© (page).

# Les autres fonctions poss√®de une structure similaire, vous pouvez utiliser ces explications comme
# source en cas d'incompr√©hension.
def fetch_popular_movies(api_key, language='en-US', page=1):
    url = f"https://api.themoviedb.org/3/movie/popular?api_key={api_key}&language={language}&page={page}"
    response = requests.get(url)
    data = response.json()
    return data['results']

# D√©finit une fonction nomm√©e "fetch_movie_detail" pour r√©cup√©rer les infos d'un film via ID.
def fetch_movie_details(movie_id, api_key, language='en-US'):
    url = f"https://api.themoviedb.org/3/movie/{movie_id}?api_key={api_key}&language={language}"
    response = requests.get(url)
    data = response.json()
    return data

# D√©finit une fonction nomm√©e "fetch_poster" pour r√©cup√©rer l'affiche d'un film via son ID.
def fetch_poster(movie_id, api_key):
    movie_details = fetch_movie_details(movie_id, api_key)
    poster_path = movie_details['poster_path']
    full_path = f"https://image.tmdb.org/t/p/w500{poster_path}"
    return full_path

# D√©finit une fonction nomm√©e "fetch_movie_genres" pour r√©cup√©rer les genres disponibles (API TMDB).
def fetch_movie_genres(api_key, language='en-US'):
    url = f"https://api.themoviedb.org/3/genre/movie/list?api_key={api_key}&language={language}"
    response = requests.get(url)
    data = response.json()
    return data['genres']

# D√©finit une fonction nomm√©e "fetch_movie_years" pour r√©cup√©rer les ann√©es disponibles (invers√©es).
def fetch_movie_years(api_key, start_year=1900, end_year=2022):
    return list(reversed(range(start_year, end_year+1)))

# D√©finit une fonction nomm√©e "search_movies_by_title" pour rechercher les films par titre
def search_movies_by_title(api_key, title):
    url = f"https://api.themoviedb.org/3/search/movie?api_key={api_key}&query={title}"
    response = requests.get(url)
    data = response.json()
    return data['results']

# D√©finit une fonction nomm√©e "search_movies_by_genre" pour rechercher les films par genre
def search_movies_by_genre(api_key, genre_id):
    url = f"https://api.themoviedb.org/3/discover/movie?api_key={api_key}&with_genres={genre_id}"
    response = requests.get(url)
    data = response.json()
    return data['results']

# D√©finit une fonction nomm√©e "search_movies_by_year" pour rechercher les films par ann√©e
def search_movies_by_year(api_key, year):
    url = f"https://api.themoviedb.org/3/discover/movie?api_key={api_key}&primary_release_year={year}"
    response = requests.get(url)
    data = response.json()
    return data['results']

api_key = "5357bdc3c9188e1ab89368e2b9b8cab7"

# Configuration de la page Streamlit
st.set_page_config(
    page_title="Syst√®me de recommandation de film",
    page_icon="üé•",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS pour zoom sur les affiches.
st.markdown(
    """
    <style>
    .hover-effect:hover {
        transform: scale(1.10);
        transition: transform 0.3s ease;
    }
    </style>
    """,
    unsafe_allow_html=True
)

# Ajustement de la largeur de la barre lat√©rale.
st.sidebar.markdown('<style>.sidebar-content {width: 30%;}</style>', unsafe_allow_html=True)

# Barre lat√©rale pour les options de tri.
with st.sidebar:
    st.image("C:\\Users\\teddy\\Documents\\Projet.2\\Cinema-PNG-HD-3980430216.png", width=150)
    st.header("Options de tri")
    st.write("### Rechercher des films par :")
    selected_genre = st.selectbox("Genre", ["Tous les genres"] + [genre['name'] for genre in fetch_movie_genres(api_key)])
    selected_year = st.selectbox("Ann√©e", ["Toutes les ann√©es"] + [str(year) for year in fetch_movie_years(api_key)])
    selected_title = st.text_input("Titre du film")
    search_button = st.button("Rechercher")
    st.write("### Ou afficher les films populaires :")
    popular_movies_button = st.button("Films populaires")


st.markdown('<h1 style="text-align: center;">Syst√®me de recommandation de film</h1>', unsafe_allow_html=True)
st.write('### Trouve le film qui te correspond !')

if search_button:
    if selected_title:
        movies = search_movies_by_title(api_key, selected_title)
    elif selected_genre != "Tous les genres" and selected_year != "Toutes les ann√©es":
        genre_id = next((genre['id'] for genre in fetch_movie_genres(api_key) if genre['name'] == selected_genre), None)
        if genre_id:
# R√©cup√©rer les films correspondant au genre s√©lectionn√©.
            movies = search_movies_by_genre(api_key, genre_id)
# V√©rifier si la liste de films est vide.
            if not movies:
                st.warning("Aucun film trouv√© pour ce genre et cette ann√©e.")
                st.stop()
# Filtrer ces films par ann√©e / genre.
            movies = [movie for movie in movies if movie['release_date'].startswith(selected_year)]
        else:
            st.error("Le genre s√©lectionn√© n'est pas valide.")
            st.stop()
    elif selected_genre != "Tous les genres":
        genre_id = next((genre['id'] for genre in fetch_movie_genres(api_key) if genre['name'] == selected_genre), None)
        if genre_id:
            movies = search_movies_by_genre(api_key, genre_id)
        else:
            st.error("Le genre s√©lectionn√© n'est pas valide.")
            st.stop()
    elif selected_year != "Toutes les ann√©es":
        movies = search_movies_by_year(api_key, selected_year)
    else:
        st.error("Veuillez sp√©cifier au moins un crit√®re de recherche.")


       
elif popular_movies_button:
# Affichage des films populaires par d√©faut.
    movies = fetch_popular_movies(api_key)

import streamlit.components.v1 as components

if 'movies' in locals() and movies:
    col1, col2, col3, col4, col5 = st.columns(5)
    columns = [col1, col2, col3, col4, col5]
    for i, movie in enumerate(movies[:5]):
        with columns[i]:
            poster = fetch_poster(movie["id"], api_key)
            # Affichage de l'affiche du film avec les informations superpos√©es
            st.markdown(f'<div style="position: relative;">'
                        f'<a href="{fetch_movie_details(movie["id"], api_key)["homepage"]}" target="_blank">'
                        f'<img src="{poster}" class="hover-effect" width="250">'
                        f'<div style="position: absolute; bottom: 10px; left: 10px; padding: 5px; background-color: rgba(0, 0, 0, 0.5); color: white; font-size: 14px; font-weight: bold; width: 120px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;">'
                        f'{movie["title"][:25] + "..." if len(movie["title"]) > 28 else movie["title"]}<br>'
                        f"Ann√©e : {movie['release_date'].split('-')[0]}"
                        f"<br>Note : {movie['vote_average']}"
                        f"<br>‚≠ê{'‚≠ê' * int(movie['vote_average'] / 2)}"
                        f'</div></a></div>', unsafe_allow_html=True)
    for movie in movies[:5]:
        st.markdown(f'<div id="popup-{movie["id"]}" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1;">'
                    f'<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; height: 80%; background-color: white; padding: 20px; overflow-y: auto;">'
                    f'<a href="#" onclick="document.getElementById(\'popup-{movie["id"]}\').style.display=\'none\'; return false;" style="position: absolute; top: 10px; right: 10px; font-size: 24px; color: black;">&times;</a>'
                    f'<h2>{movie["title"]}</h2>'
                    f'<p>Ann√©e : {movie["release_date"].split("-")[0]}</p>'
                    f'<p>Note : {movie["vote_average"]}</p>'
                    f'<p>‚≠ê{"‚≠ê" * int(movie["vote_average"] / 2)}</p>'
                    f'</div></div>', unsafe_allow_html=True)





